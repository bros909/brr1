<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MVVM Example with Vanilla JS & ES2020</title>
    <style>
        label, input, h2 {
            margin: 10px;
        }
    </style>
</head>
<body>

<div>
    <label>Enter your name: </label>
    <input id="nameInput" type="text" />
    <h2>Hello, <span id="nameDisplay">World</span>!</h2>
</div>

<script>
    // Объявляем объект model, который будет представлять нашу базовую модель данных.
const model = {
    name: "World"  // Начальное значение имени установлено как "World".
};

// Объявляем объект viewModel, который будет служить мостом между моделью и представлением.
const viewModel = {
    // Метод для установки нового значения имени.
    setName(newName) {
        // Используем Nullish Coalescing Operator (??), чтобы установить значение "World", 
        // если newName является null или undefined.
        model.name = newName ?? "World";  

        // После установки нового значения имени обновляем представление.
        view.updateNameDisplay();
    },

    // Метод для получения значения имени.
    getName() {
        // Используем Optional Chaining (?.) для безопасного доступа к свойству name.
        // Если model или model.name не определены, то вернется undefined.
        // С помощью Nullish Coalescing Operator (??) устанавливаем значение "World" 
        // в случае, если model.name является null или undefined.
        return model.name?.toString() ?? "World";
    }
};

// Объявляем объект view, который будет отвечать за взаимодействие с пользовательским интерфейсом.
const view = {
    // Получаем элементы DOM, с которыми будем взаимодействовать.
    inputElement: document.getElementById("nameInput"),
    displayElement: document.getElementById("nameDisplay"),

    // Метод инициализации, который настраивает обработчики событий для элементов интерфейса.
    init() {
        // Добавляем обработчик события "input" для поля ввода.
        // Каждый раз, когда значение в поле ввода меняется, мы устанавливаем новое имя через viewModel.
        this.inputElement.addEventListener("input", () => {
            viewModel.setName(view.inputElement.value);
        });
    },

    // Метод для обновления текстового содержимого элемента, который отображает имя.
    updateNameDisplay() {
        // Устанавливаем текст элемента равным значению имени, полученному из viewModel.
        this.displayElement.textContent = viewModel.getName();
    }
};

// Инициализируем представление, чтобы настроить обработчики событий.
view.init();


</script>
</body>
</html>

<!-- В JavaScript объекты играют важную роль, и они являются одной из основных структур данных в языке. Объекты в JavaScript используются для хранения коллекций данных в форме пар ключ-значение и для объявления функций, которые работают с этими данными.

Объясню причины, почему в примере используются объекты:

Организация кода: Объекты помогают структурировать и организовывать код, делая его более читаемым и понятным. Когда вы группируете связанные функции и переменные в одном объекте, вы создаете ясный контекст для этой группы.

Инкапсуляция: Одной из основных идей объектно-ориентированного программирования (ООП) является инкапсуляция. Это означает, что данные объекта и функции, которые работают с этими данными, упакованы вместе. В нашем примере объект viewModel инкапсулирует логику, связанную с обработкой данных модели.

Переиспользуемость: Объекты можно легко повторно использовать в других частях приложения или даже в других приложениях. Например, вы можете создать объект, который содержит набор утилитарных функций, и использовать этот объект в разных проектах.

Расширяемость: Если вы решите добавить новую функциональность или изменить существующую, объекты обычно легче модифицировать, поскольку связанные функции и данные уже сгруппированы вместе. Вы можете просто добавить новые свойства или методы к объекту.

Эмуляция пространства имен: JavaScript не имеет встроенной поддержки пространств имен (namespaces) так, как это есть в некоторых других языках. Но объекты можно использовать для создания структуры, похожей на пространство имен, что помогает избегать конфликтов имен.

В нашем примере:

model представляет базовую структуру данных.
viewModel содержит методы для работы с данными и связывает модель с представлением.
view занимается взаимодействием с пользовательским интерфейсом.
Разделение на эти три объекта помогает четко разделить ответственности в коде, что делает его более управляемым и читаемым. -->